<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Sedlying__Sedlexing (sedlying.Sedlying__Sedlexing)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">sedlying</a> &#x00BB; Sedlying__Sedlexing</nav><h1>Module <code>Sedlying__Sedlexing</code></h1><p>This module is roughly equivalent to the module Sedlexing of sedlex, except that its lexbuffers handle Unicode code points marked with whether they are a final code point before a boundary or not.</p><nav class="toc"><ul><li><a href="#creating-a-lexer-buffer">Creating a lexer buffer</a></li><li><a href="#interface-for-lexer-semantic-actions">Interface for lexer semantic actions</a></li><li><a href="#interface-for-lexer-semantic-actions">Interface for lexer semantic actions</a><ul><li><a href="#lexemes">Lexemes</a><ul><li><a href="#code-point-lexemes">Code point lexemes</a></li><li><a href="#utf_8-string-lexemes">Utf_8 string lexemes</a></li></ul></li></ul></li></ul></nav></header><dl><dt class="spec type" id="type-lybuf"><a href="#type-lybuf" class="anchor"></a><code><span class="keyword">type</span> lybuf</code></dt></dl><section><header><h2 id="creating-a-lexer-buffer"><a href="#creating-a-lexer-buffer" class="anchor"></a>Creating a lexer buffer</h2></header><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : <span>?&#8288;filename:string</span> <span>&#45;&gt;</span> <span><span>[ <span>`LastUchar of Stdlib.Uchar.t</span> <span><span>| `Uchar</span> of Stdlib.Uchar.t</span> ]</span> Gen.t</span> <span>&#45;&gt;</span> <a href="index.html#type-lybuf">lybuf</a></code></dt><dd><p><code>create ?filename gen</code> creates a lexer buffer, with the optionally provided <code>filename</code> used for outputing lexing positions. When the lexer needs characters, it will call <code>gen</code> for more characters. If the generator returns <code>`LastUchar c</code> it means that the code point <code>c</code> is a final code point before a boundary.</p></dd></dl></section><section><header><h2 id="interface-for-lexer-semantic-actions"><a href="#interface-for-lexer-semantic-actions" class="anchor"></a>Interface for lexer semantic actions</h2></header><dl><dt class="spec value" id="val-start"><a href="#val-start" class="anchor"></a><code><span class="keyword">val</span> start : <a href="index.html#type-lybuf">lybuf</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>start buf</code> sets the internal slot of the buffer to <code>-1</code> and sets the <code>lexeme_start</code> position and backtrack position to the current position.</p></dd></dl><dl><dt class="spec value" id="val-next"><a href="#val-next" class="anchor"></a><code><span class="keyword">val</span> next : <a href="index.html#type-lybuf">lybuf</a> <span>&#45;&gt;</span> <span>Stdlib.Uchar.t option</span></code></dt><dd><p><code>next buf</code> extracts the next code point form the lexer buffer and increments to the current position. If the input stream is exhausted it returns <code>None</code>. If the following are encounted at a final code point position, the tracked line number in incremented.</p><ul><li>Line Feed (U+000A)</li><li>Vertical Tab (U+000B)</li><li>Form Feed (U+000C)</li><li>Carriage Return (U+000D)</li><li>Next Line (U+0085)</li><li>Line Separator (U+2028)</li><li>Paragraph Separator (U+2029)</li></ul></dd></dl><dl><dt class="spec value" id="val-mark"><a href="#val-mark" class="anchor"></a><code><span class="keyword">val</span> mark : <a href="index.html#type-lybuf">lybuf</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p>If the current code point position is a final position <code>mark buf i</code> stores the integer <code>i</code> in the interal slot and sets the backtrack position to the current position. If the current code point position is not, <code>mark buf i</code> does nothing.</p></dd></dl><dl><dt class="spec value" id="val-backtrack"><a href="#val-backtrack" class="anchor"></a><code><span class="keyword">val</span> backtrack : <a href="index.html#type-lybuf">lybuf</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>backtrack buf</code> returns the value stored in the internal slot of the buffer, and set the current position to the backtrack position.</p></dd></dl></section><section><header><h2 id="interface-for-lexer-semantic-actions"><a href="#interface-for-lexer-semantic-actions" class="anchor"></a>Interface for lexer semantic actions</h2></header><dl><dt class="spec value" id="val-lexeme_length"><a href="#val-lexeme_length" class="anchor"></a><code><span class="keyword">val</span> lexeme_length : <a href="index.html#type-lybuf">lybuf</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>lexeme_length buf</code> returns the number of code points in the lexeme.</p></dd></dl><dl><dt class="spec value" id="val-lexeme_locs"><a href="#val-lexeme_locs" class="anchor"></a><code><span class="keyword">val</span> lexeme_locs : <a href="index.html#type-lybuf">lybuf</a> <span>&#45;&gt;</span> int * int</code></dt><dd><p><code>lexeme_length buf</code> returns the code point locations of the lexeme.</p></dd></dl><dl><dt class="spec value" id="val-lexing_positions"><a href="#val-lexing_positions" class="anchor"></a><code><span class="keyword">val</span> lexing_positions : <a href="index.html#type-lybuf">lybuf</a> <span>&#45;&gt;</span> Stdlib.Lexing.position * Stdlib.Lexing.position</code></dt><dd><p><code>lexing_positions buf</code> returns the lexing positions of the lexeme.</p></dd></dl><section><header><h3 id="lexemes"><a href="#lexemes" class="anchor"></a>Lexemes</h3></header><aside><p>We offer several kinds of lexemes. Some lexeme functions segment the lememe by code point boundaries.</p></aside><aside><p>If you are unsure about which kind of lexeme work best for your use case, the following (which is the same as <code>Utf_8.lexeme_segments_arr</code>) is a good default.</p></aside><dl><dt class="spec value" id="val-lexeme"><a href="#val-lexeme" class="anchor"></a><code><span class="keyword">val</span> lexeme : <a href="index.html#type-lybuf">lybuf</a> <span>&#45;&gt;</span> <span>string array</span></code></dt><dd><p><code>lexeme buf</code> returns the lexeme as an array of utf_8 segments.</p></dd></dl><section><header><h4 id="code-point-lexemes"><a href="#code-point-lexemes" class="anchor"></a>Code point lexemes</h4></header><div class="spec module" id="module-Code_point"><a href="#module-Code_point" class="anchor"></a><code><span class="keyword">module</span> <a href="Code_point/index.html">Code_point</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h4 id="utf_8-string-lexemes"><a href="#utf_8-string-lexemes" class="anchor"></a>Utf_8 string lexemes</h4></header><div class="spec module" id="module-Utf_8"><a href="#module-Utf_8" class="anchor"></a><code><span class="keyword">module</span> <a href="Utf_8/index.html">Utf_8</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></section></section></div></body></html>